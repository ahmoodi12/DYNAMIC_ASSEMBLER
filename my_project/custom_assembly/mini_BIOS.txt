# custom_assembly\mini_BIOS.txt isa_files\minimal_cpu.json -f lgsm -e big -d -s 63488

// interrupt vector
.org $0xf7ff
.num 0x1000

.include "mini_definitions.txt"


.org $0xf700
.block
init:
    clr true, sp
    ldi true, r1, boot_str
    ldi true, r2, 0x80
    stoi true, text_disp, r2
    call print_str
    ldi true, r0, 0x7f
    wait:
        lodi true, buttons, r1
        testi r1, 0x20            # check if the esc button was pressed
        jmpi nz, print_prompt     # if z = 0
        for r0, wait 

    ldi true, r0, 0x80
    stoi true, text_disp, r0
    jmpi true, skip_terminal

    print_prompt:
        // reseting the text disp
        ldi true, r0, 0x80          
        stoi true, text_disp, r0

        ldi true, r1, command_str
        call print_str
        ldi true, r1, "\n"
        ldi true, r2, keyboard_buffer
        stoi true, text_disp, r1
        call command_prompt


    skip_terminal:

    ldi true, r0, 0xf5ff
    stoi true, rom_end, r0
    clr true, r0
    stoi true, rom_start, r0

    clr true, r1
    clr true, r2
    clr true, r3
    clr true, r4
    clr true, r5

    // wait for the rom to interrupt saying it was done loading
    ldi true, flags, 0b1010_1010__1011_0000   // sets int enable and the and a specific pattern to mark that this is from the BIOS
    hlt


    // infinite loop unless broken
    
    handle_newline:
        # null terminate the keyboard buffer
        ldi true, r1, 0  
        sto true, r2, r1    // stores to the keyboard buffer

        # check for exit
        ldi true, r3, command_exit
        ldi true, r2, keyboard_buffer   // is gonna be the pointer to the list that is going to have the typed chars

        call find_str

        testi flags, flag_A
        jmpi neq, halt

    command_prompt:
        # print "> "
        ldi true, r1, ">"
        stoi true, text_disp, r1
        ldi true, r1, " "
        stoi true, text_disp, r1

    command_prompt_loop:
        # load and check if keyboard has chars
        lodi true, keyboard, r1
        testi r1, 0x80 
        jmpi z, command_prompt_loop

        # get the acsii
        andi r1, 0x7f, r1 

        # check for backspaces
        cmpi r1, 8
        jmpi neq, not_backspace

        # check if we can delete 
        cmpi r2, keyboard_buffer
        jmpi eq, command_prompt_loop

        dec r2
        stoi true, text_disp, r1
        jmpi true, command_prompt_loop

    not_backspace:
        stoi true, text_disp, r1

        cmpi r1, "\n"
        jmpi eq, handle_newline

        sto true, r2, r1    // stores to the keyboard buffer
        inc r2
    
    jmpi true, command_prompt_loop

halt:
    ldi true, r1, command_exit
    call print_str
    hlt
    
    
.block
// the exp str pointer is in r3, r2 is the start of the list where the chars where stored.
find_str:
    mov true, r2, r6
    loop:
        lod true, r2, r4   // r4 is the gotten char
        lod true, r3, r5   // r5 is the exp char

        andi r5, 0x7f, r5
        
        cmpi r5, 0
        jmpi neq, continue_comparsion

        cmpi r4, 0 
        jmpi eq, same

        jmpi true, not_same

        continue_comparsion:
        inc r2
        inc r3
        cmp r4, r5
        jmpi eq, loop
    
    not_same:
        andi flags, not_flag_A, flags
        jmpi true, return
    same:
        ori flags, flag_A, flags
    return:
        mov true, r6, r2
        ret


.block
print_str:      // prints from pointer in r1
    push r2
    jmpi true, start
    loop:
        stoi true, text_disp, r2
    start:
        lod true, r1, r2
        inc r1
        cmpi r2, 0  
        jmpi nz, loop
    pop r2
    ret


boot_str:
    .num "Booting...\n", 0

command_str:
    .num "command prompt:", 0

command_exit:
    .num "exit", 0

#command_run:
#    .num "run", 0
#
#command_mem:
#    .num "mem", 0

.org $0x0200
keyboard_buffer:
